{"version":3,"sources":["webpack:///./node_modules/ngeohash/main.js"],"names":["BASE32_CODES","BASE32_CODES_DICT","i","length","charAt","ENCODE_AUTO","SIGFIG_HASH_LENGTH","encode","latitude","longitude","numberOfChars","Error","decSigFigsLat","split","decSigFigsLong","numberOfSigFigs","Math","max","undefined","mid","chars","bits","bitsTotal","hash_value","maxLat","minLat","maxLon","minLon","code","push","join","encode_int","bitDepth","combinedBits","decode_bbox","hash_string","isLon","hashValue","l","toLowerCase","bit","decode_bbox_int","hashInt","latBit","lonBit","step","get_bit","position","pow","decode","hashString","bbox","lat","lon","latErr","lonErr","error","decode_int","hash_int","neighbor","direction","lonLat","neighborLat","neighborLon","neighbor_int","lonlat","neighbor_lat","neighbor_lon","neighbors","hashstringLength","neighborHashList","encodeNeighbor","neighborLatDir","neighborLonDir","neighbors_int","neighborHashIntList","encodeNeighbor_int","bboxes","hashSouthWest","hashNorthEast","latLon","perLat","perLon","boxSouthWest","boxNorthEast","latStep","round","lonStep","hashList","bboxes_int","latlon","geohash","encode_uint64","decode_uint64","decode_bbox_uint64","module","exports"],"mappings":"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","file":"js/Geohash.ab011d12.js","sourcesContent":["/**\n * Copyright (c) 2011, Sun Ning.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use, copy,\n * modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n */\n\nvar BASE32_CODES = \"0123456789bcdefghjkmnpqrstuvwxyz\";\nvar BASE32_CODES_DICT = {};\nfor (var i = 0; i < BASE32_CODES.length; i++) {\n  BASE32_CODES_DICT[BASE32_CODES.charAt(i)] = i;\n}\n\nvar ENCODE_AUTO = 'auto';\n/**\n * Significant Figure Hash Length\n *\n * This is a quick and dirty lookup to figure out how long our hash\n * should be in order to guarantee a certain amount of trailing\n * significant figures. This was calculated by determining the error:\n * 45/2^(n-1) where n is the number of bits for a latitude or\n * longitude. Key is # of desired sig figs, value is minimum length of\n * the geohash.\n * @type Array\n */\n//     Desired sig figs:  0  1  2  3  4   5   6   7   8   9  10\nvar SIGFIG_HASH_LENGTH = [0, 5, 7, 8, 11, 12, 13, 15, 16, 17, 18];\n/**\n * Encode\n *\n * Create a Geohash out of a latitude and longitude that is\n * `numberOfChars` long.\n *\n * @param {Number|String} latitude\n * @param {Number|String} longitude\n * @param {Number} numberOfChars\n * @returns {String}\n */\nvar encode = function (latitude, longitude, numberOfChars) {\n  if (numberOfChars === ENCODE_AUTO) {\n    if (typeof(latitude) === 'number' || typeof(longitude) === 'number') {\n      throw new Error('string notation required for auto precision.');\n    }\n    var decSigFigsLat = latitude.split('.')[1].length;\n    var decSigFigsLong = longitude.split('.')[1].length;\n    var numberOfSigFigs = Math.max(decSigFigsLat, decSigFigsLong);\n    numberOfChars = SIGFIG_HASH_LENGTH[numberOfSigFigs];\n  } else if (numberOfChars === undefined) {\n    numberOfChars = 9;\n  }\n\n  var chars = [],\n  bits = 0,\n  bitsTotal = 0,\n  hash_value = 0,\n  maxLat = 90,\n  minLat = -90,\n  maxLon = 180,\n  minLon = -180,\n  mid;\n  while (chars.length < numberOfChars) {\n    if (bitsTotal % 2 === 0) {\n      mid = (maxLon + minLon) / 2;\n      if (longitude > mid) {\n        hash_value = (hash_value << 1) + 1;\n        minLon = mid;\n      } else {\n        hash_value = (hash_value << 1) + 0;\n        maxLon = mid;\n      }\n    } else {\n      mid = (maxLat + minLat) / 2;\n      if (latitude > mid) {\n        hash_value = (hash_value << 1) + 1;\n        minLat = mid;\n      } else {\n        hash_value = (hash_value << 1) + 0;\n        maxLat = mid;\n      }\n    }\n\n    bits++;\n    bitsTotal++;\n    if (bits === 5) {\n      var code = BASE32_CODES[hash_value];\n      chars.push(code);\n      bits = 0;\n      hash_value = 0;\n    }\n  }\n  return chars.join('');\n};\n\n/**\n * Encode Integer\n *\n * Create a Geohash out of a latitude and longitude that is of 'bitDepth'.\n *\n * @param {Number} latitude\n * @param {Number} longitude\n * @param {Number} bitDepth\n * @returns {Number}\n */\nvar encode_int = function (latitude, longitude, bitDepth) {\n\n  bitDepth = bitDepth || 52;\n\n  var bitsTotal = 0,\n  maxLat = 90,\n  minLat = -90,\n  maxLon = 180,\n  minLon = -180,\n  mid,\n  combinedBits = 0;\n\n  while (bitsTotal < bitDepth) {\n    combinedBits *= 2;\n    if (bitsTotal % 2 === 0) {\n      mid = (maxLon + minLon) / 2;\n      if (longitude > mid) {\n        combinedBits += 1;\n        minLon = mid;\n      } else {\n        maxLon = mid;\n      }\n    } else {\n      mid = (maxLat + minLat) / 2;\n      if (latitude > mid) {\n        combinedBits += 1;\n        minLat = mid;\n      } else {\n        maxLat = mid;\n      }\n    }\n    bitsTotal++;\n  }\n  return combinedBits;\n};\n\n/**\n * Decode Bounding Box\n *\n * Decode hashString into a bound box matches it. Data returned in a four-element array: [minlat, minlon, maxlat, maxlon]\n * @param {String} hash_string\n * @returns {Array}\n */\nvar decode_bbox = function (hash_string) {\n  var isLon = true,\n  maxLat = 90,\n  minLat = -90,\n  maxLon = 180,\n  minLon = -180,\n  mid;\n\n  var hashValue = 0;\n  for (var i = 0, l = hash_string.length; i < l; i++) {\n    var code = hash_string[i].toLowerCase();\n    hashValue = BASE32_CODES_DICT[code];\n\n    for (var bits = 4; bits >= 0; bits--) {\n      var bit = (hashValue >> bits) & 1;\n      if (isLon) {\n        mid = (maxLon + minLon) / 2;\n        if (bit === 1) {\n          minLon = mid;\n        } else {\n          maxLon = mid;\n        }\n      } else {\n        mid = (maxLat + minLat) / 2;\n        if (bit === 1) {\n          minLat = mid;\n        } else {\n          maxLat = mid;\n        }\n      }\n      isLon = !isLon;\n    }\n  }\n  return [minLat, minLon, maxLat, maxLon];\n};\n\n/**\n * Decode Bounding Box Integer\n *\n * Decode hash number into a bound box matches it. Data returned in a four-element array: [minlat, minlon, maxlat, maxlon]\n * @param {Number} hashInt\n * @param {Number} bitDepth\n * @returns {Array}\n */\nvar decode_bbox_int = function (hashInt, bitDepth) {\n\n  bitDepth = bitDepth || 52;\n\n  var maxLat = 90,\n  minLat = -90,\n  maxLon = 180,\n  minLon = -180;\n\n  var latBit = 0, lonBit = 0;\n  var step = bitDepth / 2;\n\n  for (var i = 0; i < step; i++) {\n\n    lonBit = get_bit(hashInt, ((step - i) * 2) - 1);\n    latBit = get_bit(hashInt, ((step - i) * 2) - 2);\n\n    if (latBit === 0) {\n      maxLat = (maxLat + minLat) / 2;\n    }\n    else {\n      minLat = (maxLat + minLat) / 2;\n    }\n\n    if (lonBit === 0) {\n      maxLon = (maxLon + minLon) / 2;\n    }\n    else {\n      minLon = (maxLon + minLon) / 2;\n    }\n  }\n  return [minLat, minLon, maxLat, maxLon];\n};\n\nfunction get_bit(bits, position) {\n  return (bits / Math.pow(2, position)) & 0x01;\n}\n\n/**\n * Decode\n *\n * Decode a hash string into pair of latitude and longitude. A javascript object is returned with keys `latitude`,\n * `longitude` and `error`.\n * @param {String} hashString\n * @returns {Object}\n */\nvar decode = function (hashString) {\n  var bbox = decode_bbox(hashString);\n  var lat = (bbox[0] + bbox[2]) / 2;\n  var lon = (bbox[1] + bbox[3]) / 2;\n  var latErr = bbox[2] - lat;\n  var lonErr = bbox[3] - lon;\n  return {latitude: lat, longitude: lon,\n          error: {latitude: latErr, longitude: lonErr}};\n};\n\n/**\n * Decode Integer\n *\n * Decode a hash number into pair of latitude and longitude. A javascript object is returned with keys `latitude`,\n * `longitude` and `error`.\n * @param {Number} hash_int\n * @param {Number} bitDepth\n * @returns {Object}\n */\nvar decode_int = function (hash_int, bitDepth) {\n  var bbox = decode_bbox_int(hash_int, bitDepth);\n  var lat = (bbox[0] + bbox[2]) / 2;\n  var lon = (bbox[1] + bbox[3]) / 2;\n  var latErr = bbox[2] - lat;\n  var lonErr = bbox[3] - lon;\n  return {latitude: lat, longitude: lon,\n          error: {latitude: latErr, longitude: lonErr}};\n};\n\n/**\n * Neighbor\n *\n * Find neighbor of a geohash string in certain direction. Direction is a two-element array, i.e. [1,0] means north, [-1,-1] means southwest.\n * direction [lat, lon], i.e.\n * [1,0] - north\n * [1,1] - northeast\n * ...\n * @param {String} hashString\n * @param {Array} Direction as a 2D normalized vector.\n * @returns {String}\n */\nvar neighbor = function (hashString, direction) {\n  var lonLat = decode(hashString);\n  var neighborLat = lonLat.latitude\n    + direction[0] * lonLat.error.latitude * 2;\n  var neighborLon = lonLat.longitude\n    + direction[1] * lonLat.error.longitude * 2;\n  return encode(neighborLat, neighborLon, hashString.length);\n};\n\n/**\n * Neighbor Integer\n *\n * Find neighbor of a geohash integer in certain direction. Direction is a two-element array, i.e. [1,0] means north, [-1,-1] means southwest.\n * direction [lat, lon], i.e.\n * [1,0] - north\n * [1,1] - northeast\n * ...\n * @param {String} hash_string\n * @returns {Array}\n*/\nvar neighbor_int = function(hash_int, direction, bitDepth) {\n    bitDepth = bitDepth || 52;\n    var lonlat = decode_int(hash_int, bitDepth);\n    var neighbor_lat = lonlat.latitude + direction[0] * lonlat.error.latitude * 2;\n    var neighbor_lon = lonlat.longitude + direction[1] * lonlat.error.longitude * 2;\n    return encode_int(neighbor_lat, neighbor_lon, bitDepth);\n};\n\n/**\n * Neighbors\n *\n * Returns all neighbors' hashstrings clockwise from north around to northwest\n * 7 0 1\n * 6 x 2\n * 5 4 3\n * @param {String} hash_string\n * @returns {encoded neighborHashList|Array}\n */\nvar neighbors = function(hash_string){\n\n    var hashstringLength = hash_string.length;\n\n    var lonlat = decode(hash_string);\n    var lat = lonlat.latitude;\n    var lon = lonlat.longitude;\n    var latErr = lonlat.error.latitude * 2;\n    var lonErr = lonlat.error.longitude * 2;\n\n    var neighbor_lat,\n        neighbor_lon;\n\n    var neighborHashList = [\n                            encodeNeighbor(1,0),\n                            encodeNeighbor(1,1),\n                            encodeNeighbor(0,1),\n                            encodeNeighbor(-1,1),\n                            encodeNeighbor(-1,0),\n                            encodeNeighbor(-1,-1),\n                            encodeNeighbor(0,-1),\n                            encodeNeighbor(1,-1)\n                            ];\n\n    function encodeNeighbor(neighborLatDir, neighborLonDir){\n        neighbor_lat = lat + neighborLatDir * latErr;\n        neighbor_lon = lon + neighborLonDir * lonErr;\n        return encode(neighbor_lat, neighbor_lon, hashstringLength);\n    }\n\n    return neighborHashList;\n};\n\n/**\n * Neighbors Integer\n *\n * Returns all neighbors' hash integers clockwise from north around to northwest\n * 7 0 1\n * 6 x 2\n * 5 4 3\n * @param {Number} hash_int\n * @param {Number} bitDepth\n * @returns {encode_int'd neighborHashIntList|Array}\n */\nvar neighbors_int = function(hash_int, bitDepth){\n\n    bitDepth = bitDepth || 52;\n\n    var lonlat = decode_int(hash_int, bitDepth);\n    var lat = lonlat.latitude;\n    var lon = lonlat.longitude;\n    var latErr = lonlat.error.latitude * 2;\n    var lonErr = lonlat.error.longitude * 2;\n\n    var neighbor_lat,\n        neighbor_lon;\n\n    var neighborHashIntList = [\n                            encodeNeighbor_int(1,0),\n                            encodeNeighbor_int(1,1),\n                            encodeNeighbor_int(0,1),\n                            encodeNeighbor_int(-1,1),\n                            encodeNeighbor_int(-1,0),\n                            encodeNeighbor_int(-1,-1),\n                            encodeNeighbor_int(0,-1),\n                            encodeNeighbor_int(1,-1)\n                            ];\n\n    function encodeNeighbor_int(neighborLatDir, neighborLonDir){\n        neighbor_lat = lat + neighborLatDir * latErr;\n        neighbor_lon = lon + neighborLonDir * lonErr;\n        return encode_int(neighbor_lat, neighbor_lon, bitDepth);\n    }\n\n    return neighborHashIntList;\n};\n\n\n/**\n * Bounding Boxes\n *\n * Return all the hashString between minLat, minLon, maxLat, maxLon in numberOfChars\n * @param {Number} minLat\n * @param {Number} minLon\n * @param {Number} maxLat\n * @param {Number} maxLon\n * @param {Number} numberOfChars\n * @returns {bboxes.hashList|Array}\n */\nvar bboxes = function (minLat, minLon, maxLat, maxLon, numberOfChars) {\n  numberOfChars = numberOfChars || 9;\n\n  var hashSouthWest = encode(minLat, minLon, numberOfChars);\n  var hashNorthEast = encode(maxLat, maxLon, numberOfChars);\n\n  var latLon = decode(hashSouthWest);\n\n  var perLat = latLon.error.latitude * 2;\n  var perLon = latLon.error.longitude * 2;\n\n  var boxSouthWest = decode_bbox(hashSouthWest);\n  var boxNorthEast = decode_bbox(hashNorthEast);\n\n  var latStep = Math.round((boxNorthEast[0] - boxSouthWest[0]) / perLat);\n  var lonStep = Math.round((boxNorthEast[1] - boxSouthWest[1]) / perLon);\n\n  var hashList = [];\n\n  for (var lat = 0; lat <= latStep; lat++) {\n    for (var lon = 0; lon <= lonStep; lon++) {\n      hashList.push(neighbor(hashSouthWest, [lat, lon]));\n    }\n  }\n\n  return hashList;\n};\n\n/**\n * Bounding Boxes Integer\n *\n * Return all the hash integers between minLat, minLon, maxLat, maxLon in bitDepth\n * @param {Number} minLat\n * @param {Number} minLon\n * @param {Number} maxLat\n * @param {Number} maxLon\n * @param {Number} bitDepth\n * @returns {bboxes_int.hashList|Array}\n */\nvar bboxes_int = function(minLat, minLon, maxLat, maxLon, bitDepth){\n    bitDepth = bitDepth || 52;\n\n    var hashSouthWest = encode_int(minLat, minLon, bitDepth);\n    var hashNorthEast = encode_int(maxLat, maxLon, bitDepth);\n\n    var latlon = decode_int(hashSouthWest, bitDepth);\n\n    var perLat = latlon.error.latitude * 2;\n    var perLon = latlon.error.longitude * 2;\n\n    var boxSouthWest = decode_bbox_int(hashSouthWest, bitDepth);\n    var boxNorthEast = decode_bbox_int(hashNorthEast, bitDepth);\n\n    var latStep = Math.round((boxNorthEast[0] - boxSouthWest[0])/perLat);\n    var lonStep = Math.round((boxNorthEast[1] - boxSouthWest[1])/perLon);\n\n    var hashList = [];\n\n    for(var lat = 0; lat <= latStep; lat++){\n        for(var lon = 0; lon <= lonStep; lon++){\n            hashList.push(neighbor_int(hashSouthWest,[lat, lon], bitDepth));\n        }\n    }\n\n    return hashList;\n};\n\nvar geohash = {\n  'ENCODE_AUTO': ENCODE_AUTO,\n  'encode': encode,\n  'encode_uint64': encode_int, // keeping for backwards compatibility, will deprecate\n  'encode_int': encode_int,\n  'decode': decode,\n  'decode_int': decode_int,\n  'decode_uint64': decode_int, // keeping for backwards compatibility, will deprecate\n  'decode_bbox': decode_bbox,\n  'decode_bbox_uint64': decode_bbox_int, // keeping for backwards compatibility, will deprecate\n  'decode_bbox_int': decode_bbox_int,\n  'neighbor': neighbor,\n  'neighbor_int': neighbor_int,\n  'neighbors': neighbors,\n  'neighbors_int': neighbors_int,\n  'bboxes': bboxes,\n  'bboxes_int': bboxes_int\n};\n\nmodule.exports = geohash;\n"],"sourceRoot":""}